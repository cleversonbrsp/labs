# =============================================================================
# pipeline-connect-kind.yml - Pipeline CI: build + deploy no Kind
# =============================================================================
# Faz checkout -> build Maven (mock-connect) -> Docker build -> kind load
# -> kubectl apply (namespace, config-server, connect) -> rollout restart connect.
# O rollout restart garante novos pods com a imagem recém-carregada (mesma tag);
# RollingUpdate padrão = sem queda (zero downtime). Roda em self-hosted
# para que kubectl e kind executem na máquina onde o cluster Kind está; assim
# o deploy vai para o SEU cluster (ex.: dev-cluster). NAMESPACE=nvt-cnt;
# KIND_CLUSTER_NAME deve bater com o nome do seu cluster (ex.: dev-cluster).
# Conceitos (Config Server, tcpSocket, probes): ver 03 - nvt-cnt/CONCEITOS.md
# =============================================================================
name: Connect Kind (build + deploy)

on:
  push:
    branches: [main]
    paths:
      - '03 - nvt-cnt/**'
      - '.github/workflows/pipeline-connect-kind.yml'
  workflow_dispatch:

env:
  NAMESPACE: nvt-cnt
  IMAGE_NAME: connect:local
  # Nome do cluster Kind (kubectl config current-context = kind-<KIND_CLUSTER_NAME>)
  KIND_CLUSTER_NAME: dev-cluster

jobs:
  build-and-deploy:
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 8
        uses: actions/setup-java@v4
        with:
          java-version: '8'
          distribution: 'temurin'

      - name: Build mock-connect
        run: |
          cd "03 - nvt-cnt/mock-connect"
          mvn -q package -DskipTests
          echo "VERSION=$(mvn -q -Dexec.executable=echo -Dexec.args='${project.version}' --non-recursive exec:exec)" >> $GITHUB_ENV

      - name: Docker build
        run: |
          cd "03 - nvt-cnt/mock-connect"
          docker build -t ${{ env.IMAGE_NAME }} --build-arg VERSION=${{ env.VERSION }} .

      - name: Load image into Kind
        run: kind load docker-image ${{ env.IMAGE_NAME }} --name ${{ env.KIND_CLUSTER_NAME }}

      - name: Create namespace
        run: kubectl apply -f "03 - nvt-cnt/manifests/namespace.yaml"

      - name: Deploy Config Server
        run: |
          kubectl apply -f "03 - nvt-cnt/manifests/config-server/" -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/config-server -n ${{ env.NAMESPACE }} --timeout=120s

      - name: Deploy Connect
        run: |
          kubectl apply -f "03 - nvt-cnt/manifests/connect/" -n ${{ env.NAMESPACE }}
          # Força novos pods: a imagem é sempre connect:local; sem restart os pods antigos continuam
          kubectl rollout restart deployment/connect -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/connect -n ${{ env.NAMESPACE }} --timeout=180s

      - name: Verify
        run: |
          kubectl get pods,svc -n ${{ env.NAMESPACE }}
          kubectl get deployment connect -n ${{ env.NAMESPACE }} -o wide
