# =============================================================================
# pipeline-connect-kind.yml - Pipeline CI: build + deploy no Kind
# =============================================================================
# Faz checkout -> build Maven (mock-connect) -> Docker build -> kind load
# -> kubectl apply (namespace, config-server, connect) -> rollout restart connect.
# O rollout restart garante novos pods com a imagem recém-carregada (mesma tag);
# RollingUpdate padrão = sem queda (zero downtime). Roda em self-hosted
# para que kubectl e kind executem na máquina onde o cluster Kind está; assim
# o deploy vai para o SEU cluster (ex.: dev-cluster). NAMESPACE=lab-portal;
# IMAGE_NAME=portal-demo:local. KIND_CLUSTER_NAME = nome do seu cluster (ex.: dev-cluster).
# Conceitos (Config Server, tcpSocket, probes): ver 03 - nvt-cnt/README.md seção 7
# =============================================================================
name: Connect Kind (build + deploy)

on:
  push:
    branches: [main]
    paths:
      - '03 - nvt-cnt/**'
      - '.github/workflows/pipeline-connect-kind.yml'
  workflow_dispatch:

env:
  NAMESPACE: lab-portal
  IMAGE_NAME: portal-demo:local
  # Nome do cluster Kind (kubectl config current-context = kind-<KIND_CLUSTER_NAME>)
  KIND_CLUSTER_NAME: dev-cluster

jobs:
  build-and-deploy:
    # Roda na MÁQUINA onde você registrou o runner. Precisa ser a mesma onde o Kind
    # está e onde kubectl aponta para o cluster. Assim kubectl apply e kind load
    # executam localmente e o deploy vai para o SEU cluster (não para servidores GitHub).
    runs-on: self-hosted
    steps:
      # --- Código: igual ao real (checkout do repo da aplicação)
      - name: Checkout
        uses: actions/checkout@v4

      # --- Build: no real é JDK 8 + Maven (portal.jar). Aqui mesmo JDK para o mock.
      - name: Set up JDK 8
        uses: actions/setup-java@v4
        with:
          java-version: '8'
          distribution: 'temurin'

      # No real: mvn clean deploy (ou release:prepare/perform em prod). Aqui: apenas
      # package do mock-connect (Config Client + /portal/ping). POM está em mock-connect/.
      - name: Build mock-connect
        run: |
          cd "03 - nvt-cnt/mock-connect"
          mvn -q package -DskipTests
          echo "VERSION=$(mvn -q -Dexec.executable=echo -Dexec.args='${project.version}' --non-recursive exec:exec)" >> $GITHUB_ENV

      # No real: Dockerfile.prod (portal.jar + jks + opentelemetry). Aqui: Dockerfile
      # só com o JAR do mock. Tag fixa portal-demo:local.
      - name: Docker build
        run: |
          cd "03 - nvt-cnt/mock-connect"
          docker build -t ${{ env.IMAGE_NAME }} --build-arg VERSION=${{ env.VERSION }} .

      # No real: docker push para OCIR; o OKE faz pull da imagem. Aqui não há OCI:
      # kind load leva a imagem do daemon Docker local direto para os nodes do Kind,
      # sem registry na nuvem. Ver 03 - nvt-cnt/README.md seção 8.3 (Kind load).
      - name: Load image into Kind
        run: kind load docker-image ${{ env.IMAGE_NAME }} --name ${{ env.KIND_CLUSTER_NAME }}

      # No real: namespaces prod/hom já existem. Aqui: criamos lab-portal uma vez.
      - name: Create namespace
        run: kubectl apply -f "03 - nvt-cnt/manifests/namespace.yaml"

      # No real: Config Server já está no OKE (deploy separado). Aqui: aplicamos
      # ConfigMap + Deployment + Service do Config Server (modo native, properties
      # no ConfigMap). A Connect depende dele no startup; por isso aplicamos primeiro.
      - name: Deploy Config Server
        run: |
          kubectl apply -f "03 - nvt-cnt/manifests/config-server/" -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/config-server -n ${{ env.NAMESPACE }} --timeout=120s

      # No real: pipeline baixa deployment/service do devops-config (API GitHub) e
      # aplica; depois kubectl set image + rollout. Aqui: manifestos estão no repo;
      # rollout restart é necessário porque a tag é sempre portal-demo:local — sem restart
      # os pods antigos continuariam rodando (K8s não recria se o template não mudou).
      # RollingUpdate = sobe o novo pod, espera Ready, encerra o antigo (zero downtime).
      - name: Deploy Connect
        run: |
          kubectl apply -f "03 - nvt-cnt/manifests/connect/" -n ${{ env.NAMESPACE }}
          kubectl rollout restart deployment/portal-demo -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/portal-demo -n ${{ env.NAMESPACE }} --timeout=180s

      # Apenas conferência: pods e deployment no namespace lab-portal.
      - name: Verify
        run: |
          kubectl get pods,svc -n ${{ env.NAMESPACE }}
          kubectl get deployment portal-demo -n ${{ env.NAMESPACE }} -o wide
